<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Basic GUI with WebXR + Three.js</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="style.css" />

    <!-- ğŸ§± Three.js -->
    <script src="https://unpkg.com/three@0.133.0/build/three.js" crossorigin="anonymous"></script>

    <!-- ğŸ›ï¸ Tweakpane GUI -->
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.5/dist/tweakpane.min.js"></script>
  </head>

  <body>
    <script type="module">
      // ğŸ› ï¸ WebXR AR Button importieren
      import { ARButton } from "https://unpkg.com/three@0.133.0/examples/jsm/webxr/ARButton.js";

      // =======================================================
      // 1. ğŸ” GLOBALE VARIABLEN
      // =======================================================
      let camera, scene, renderer;
      let mesh;
      let pane;

      // =======================================================
      // 2. ğŸ§  EINSTELLUNGEN FÃœR DIE GUI --> ist auch eine globale Variable, die bereits mit Werten zugewiesen wird. Damit ist es ein (Java-script-)Object, also wird hier dem Objekt/Instanz PARAMS die Eigenschaft x,y und z mit entsprechenden Werten gegeben. Ist also keine Klasse, sondern bereits ein konkretes Objekt :)
      // =======================================================
      const PARAMS = {
        x: 0,
        y: 0,
        z: -0.5
      };

      // =======================================================
      // 3. ğŸš€ START
      // =======================================================
      setupGui(); // GUI vorbereiten
      init();     // Szene aufbauen
      animate();  // Renderloop starten

      // =======================================================
      // 4. ğŸ§° FUNKTIONS-DEFINITIONEN --> kÃ¶nnen auch nach gaaaanz unten geschrieben werden, da Java-Script, durch sogenanntes Hoisting, die Funktions-Definitionen auch von ganz unten beim Kompilieren nach oben zieht!
      // =======================================================

      // ğŸ›ï¸ GUI Setup mit Tweakpane
      function setupGui() {
        pane = new Tweakpane.Pane();
        pane.containerElem_.style.zIndex = "10000"; // damit GUI Ã¼ber AR liegt

        pane.addInput(PARAMS, 'x', { min: -5, max: 5, step: 0.1 });
        pane.addInput(PARAMS, 'y', { min: -5, max: 5, step: 0.1 });
        pane.addInput(PARAMS, 'z', { min: -5, max: 5, step: 0.1 });

        // Wenn Werte verÃ¤ndert werden: Objekt aktualisieren
        pane.on('change', (ev) => {   // das ist ein Eventlistener. sobald sich etwas Ã¤nder auf der GUI (der pane). dort wird erst genauer definiert WAS der Eventlistener "beobachten" soll. Und sobald eine VerÃ¤nderung dort eintritt sollt ein Callback ausgefÃ¼hrt werden = alles was in switch(type) steht. Dort wird zurÃ¼ckgegeben (Callback) was nun verÃ¤ndert werden soll, wenn eine VerÃ¤nderung "beobachtet" wurde. --> Eventlistener hÃ¶ren auf eine VerÃ¤nderung ('change' oder 'input') und tun, dann was ihnen Ã¼ber das Callback (switch() oder if statements) gesagt wird zu tun!
          const type = ev.presetKey; //hier wird auf die Keys in PARAMS (da es ja Key-Value-Pairs als EIgenschaft hat) zurÃ¼ckgegriffen. Deswegen weiÃŸ type, dass er Ã¼ber den Eventlistender beobachten soll, ob sich die Keys auf der Pane Ã¤ndern. --> siehe swich unten: dort steht wenn der Eventlistener beobachtet hat, dass sich case "x" verÃ¤ndert hat, dann verÃ¤ndere auch fÃ¼r das mesh diesen Wert usw.
          const value = ev.value;

          switch(type) {
            case 'x': mesh.position.x = value; break;
            case 'y': mesh.position.y = value; break;
            case 'z': mesh.position.z = value; break;
          }
        });
      }

      // ğŸ—ï¸ Szene, Kamera, Licht, Objekt & AR-Button
      function init() {
        const container = document.createElement("div");
        document.body.appendChild(container);

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          40
        );

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        container.appendChild(renderer.domElement);

        // ğŸ’¡ Licht
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);

        // ğŸ”· Geometrie + Material + Mesh
        const geometry = new THREE.IcosahedronGeometry(0.1, 1);
        const material = new THREE.MeshPhongMaterial({
          color: new THREE.Color("rgb(226,35,213)"),
          shininess: 6,
          flatShading: true,
          transparent: true,
          opacity: 0.8
        });

        mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(PARAMS.x, PARAMS.y, PARAMS.z);
        scene.add(mesh);

        // ğŸ“± WebXR AR Button
        const button = ARButton.createButton(renderer, {
          optionalFeatures: ["dom-overlay", "dom-overlay-for-handheld-ar"],
          domOverlay: { root: document.body }
        });

        document.body.appendChild(button);

        // ğŸ“ Reaktion auf FenstergrÃ¶ÃŸe
        window.addEventListener("resize", onWindowResize, false);
      }

      // ğŸ”„ Wenn FenstergrÃ¶ÃŸe sich Ã¤ndert â†’ Kamera & Renderer anpassen
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // ğŸï¸ Animationsloop starten (lÃ¤uft automatisch)
      function animate() {
        renderer.setAnimationLoop(render);
      }

      // ğŸ“¸ Rendering pro Frame
      function render() {
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
