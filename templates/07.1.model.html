<!DOCTYPE html>
<html lang="en">

<head>
	<title>3D Model</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="style.css">
  <script src="https://unpkg.com/three@0.133.0/build/three.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/three@0.133.0/examples/js/loaders/GLTFLoader.js"></script>
<style>

    /* Canvas: immer vorne f√ºr Touch-Interaktion */
    .three.js-canvas {
      position: absolute;
      width: 100vw; /* volle Bildschirmbreite */
      height: 100vh; /* volle Bildschirmh√∂he */
      z-index: 10; /* Canvas liegt √ºber dem Grid */
    }

    .grid-container {
      position: absolute;
      display: none; /*wird bei sessionstart durch den ARButton in display: grid; ver√§ndert*/
      grid-template-columns: 80% 20%;
      grid-template-rows: 1fr 4fr 2fr;
      gap: 0.2em;
      width: 100vw; /* volle Bildschirmbreite */
      height: 100vh; /* volle Bildschirmh√∂he */
      background-color: rgba(255, 255, 255, 0.2);
      padding: 1em;
      border-radius: 0.5em;
      box-sizing: border-box;
      overflow: hidden; /* verhindert Scrollen √ºberall */
      z-index: 5;         /* damit das Grid unter dem Three.js-canvas liegt */
      pointer-events: none;    /* Hintergrund blockiert keine Touchs */
    }
    /* Buttons im Grid weiterhin interaktiv. (Muss drin stehen, weil das grid im Hintergrund (hinter dem Three.js Canvas) ist und sonst die Buttons nicht anklickbar sind!)) */
    .grid-container button {
      pointer-events: auto;
    }

    .grid-container>div {
      color: #000;
      padding: 0.5em;
	  margin-right: 1em;
      border-radius: 0.5em;
      font-size: 1em;
      text-align: center;
    }

    .item1 {
      grid-column-start: 1;
      grid-column-end: 3;
    }

    .item2 {
      background-color: orange;
      display: none;
    }

    .item3 {
      background-color: orange;
    }

    .item4 {
	background-color: orange;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1em;
    }
    
  #textBox {
    text-align: left;
    word-wrap: break-word;
  }

  .item5 {
    background-color: orange;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .hide {
  display: none !important;
}


	/*Quiz-Buttons innerhalb eines flex-Layouts (siehe .answers)*/
	.quiz-button {
  position: relative; /* wichtig! .quiz-button:after ist ein pseudo-element, das absolut positioniert wird. Deshalb muss der Eltern-Button .quiz-button auf position: relative gesetzt werden, damit sich der Effekt nur innerhalb des Buttons ausbreitet. Ansonsten √ºberlagert der Effekt den ganzen Bildschirm*/
  background-color: #04AA6D;
  border: none;
  border-radius: 0.5em;
  font-size: 1em;
  color: #FFFFFF;
      padding: 1em;
  width: 60%;
  text-align: center;
  transition-duration: 0.4s;
  text-decoration: none;
  overflow: hidden;
  cursor: pointer;
}

.quiz-button:after {
  content: "";
  background: #f1f1f1;
  display: block;
  position: absolute;
  padding-top: 300%;
  padding-left: 350%;
  margin-left: -1em !important;
  margin-top: -120%;
  opacity: 0;
  transition: all 0.8s
}

.quiz-button:active:after {
  padding: 0;
  margin: 0;
  opacity: 1;
  transition: 0s
}

.answers {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    align-items: center;
  }
	/*Quiz-Buttons Ende*/

  /*Hinweis-Icons*/
.icon-column {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    align-items: center;
  }
  /*Hinweis-Icons Ende*/
</style>

</head>

<body>
	<script type="module">
    import { ARButton } from 'https://unpkg.com/three@0.133.0/examples/jsm/webxr/ARButton.js';
    
		let camera, scene, renderer;
		let loader; // we need to create a variable for a gltf model loader
    const models = {}; // hier speichern wir die geladenen Modelle

		init();
		animate();


		function init() {
			const container = document.createElement('div');
			document.body.appendChild(container);

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.xr.enabled = true; // we have to enable the renderer for webxr
			container.appendChild(renderer.domElement);

      renderer.domElement.classList.add("three.js-canvas"); // Hiermit werden alle Elemente von Three.js (also der Canvas von Three.js) in den Vordergrund ger√ºckt (√ºber CSS-style oben gennent three.js-canvas), sodass das grid nicht die Interaktion mit den Modellen blockiert! 


			var light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
			light.position.set(0.5, 1, 0.25);
			scene.add(light);

      // specify a model URL
      const modelUrl = 'https://raw.githubusercontent.com/sweetsharky/media/refs/heads/main/nietplatte_bearbeitet0.1_gltf/nietplatte_bearbeitet0.1.gltf'; 
      
			// create a GLTF loader object. GLTF is a 3D model format usually called the "JPEG of 3D" because it is
      // fast and efficient to use, which is ideal for the web
			loader = new THREE.GLTFLoader();
      

          // üìå Liste der Modelle
      const modelList = [
        {
          name: "Nietplatte",
          url: "https://raw.githubusercontent.com/sweetsharky/medien/refs/heads/main/nietplatte_bearbeitet0.1_gltf/nietplatte_bearbeitet0.1.gltf",
          position: { x: 0, y: 0, z: -0.3 },
          scale: 0.002
        },
        {
          name: "Schiff",
          url: "https://raw.githubusercontent.com/sweetsharky/medien/refs/heads/main/the_gokstad_ship__gokstadsskeppet/scene.gltf",
          position: { x: 0.3, y: 0, z: -0.3 },
          scale: 0.01
        }
      ];

          // üìå Modelle laden
      modelList.forEach(item => {
        loader.load(item.url, gltf => {
          const model = gltf.scene;
          model.scale.multiplyScalar(item.scale);
          model.position.set(item.position.x, item.position.y, item.position.z);
          model.visible = false; // unsichtbar am Anfang
          scene.add(model);
          models[item.name] = model; // im Objekt speichern
          console.log(`Model "${item.name}" geladen`);
        });
      });
      // learn about other types of 3D model formats you can use here: 
      // https://threejs.org/docs/#manual/en/introduction/Loading-3D-models


				// onProgress callback: optional function for showing progress on model load
				//function (xhr) {
		      // console.log((xhr.loaded / xhr.total * 100) + '% loaded' );},
				
			

			document.body.appendChild(ARButton.createButton(renderer, {
				optionalFeatures: ["dom-overlay", "dom-overlay-for-handheld-ar"],
          		domOverlay: { root: document.body}
			}));


      // Wenn eine AR-Session startet ‚Üí UI einblenden
        renderer.xr.addEventListener('sessionstart', () => {
          document.querySelector('.grid-container').style.display = 'grid';
        });

        // Wenn AR-Session beendet ‚Üí UI ausblenden
        renderer.xr.addEventListener('sessionend', () => {
          document.querySelector('.grid-container').style.display = 'none';
        });

              //Button, um UI-Panel(grid-Layout) zu sichtbar zu machen/unsichtbar
      document.getElementById('toggle-panel').addEventListener('click', () => {
        document.querySelector('.grid-container').classList.toggle('hide');
      });

            window.addEventListener('resize', onWindowResize, false);

              // üìå Buttons f√ºr Modelle
                document.getElementById("toggle-nietplatte").addEventListener("click", () => toggleModel("Nietplatte"));
                document.getElementById("toggle-schiff").addEventListener("click", () => toggleModel("Schiff"));
              }

              function toggleModel(name) {
                if (models[name]) {
                  models[name].visible = !models[name].visible;
                  console.log(`${name} ist jetzt ${models[name].visible ? "sichtbar" : "unsichtbar"}`);
                }

      //ft_model_rot/clickable - Funktion, um Modell mit touch-swipes zu rotieren und anglickbar zu machen
        //modell rotieren       
        let previousTouch = null;
        let rotating = false; // Flag, ob Rotation aktiv ist. Erst sobald raycasting anzeigt, dass auf Model geklickt wurde wird rotating auf true gesetzt. Nur wenn Modell ber√ºhrt wird, kann Modell also gedreht werden.

        renderer.domElement.addEventListener('touchstart', (event) => {
          if (event.touches.length === 1 && model) {
            const touch = new THREE.Vector2();
            touch.x = (event.touches[0].pageX / window.innerWidth) * 2 - 1;
            touch.y = -(event.touches[0].pageY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(touch, camera);
            const intersects = raycaster.intersectObject(model, true);

            if (intersects.length > 0) {
              rotating = true; // Drehung aktivieren
              previousTouch = { x: event.touches[0].pageX, y: event.touches[0].pageY };
            }
          }
        }, false);

        renderer.domElement.addEventListener('touchmove', (event) => {
          if (event.touches.length === 1 && previousTouch && rotating && model) {
            const deltaX = event.touches[0].pageX - previousTouch.x;
            const deltaY = event.touches[0].pageY - previousTouch.y;

            model.rotation.y += deltaX * 0.01;
            model.rotation.x += deltaY * 0.01;

            previousTouch = { x: event.touches[0].pageX, y: event.touches[0].pageY };
          }
        }, false);

        renderer.domElement.addEventListener('touchend', () => {
          rotating = false;
          previousTouch = null;
        }, false);

          //model anklickbar machen

		}/*function init() zuende*/



    // Anpassung bei Fenstergr√∂√üe √§ndern ‚Üí Kamera, Renderer und Grid
    function onWindowResize() {
        // Three.js anpassen
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);       
    }



		function animate() {
			renderer.setAnimationLoop(render);
		}

		function render() {
			renderer.render(scene, camera);
		}

	</script>

<div class="grid-container">
  <div class="item1">Auf den Spuren der Wikinger in Duisburg</div>
  <div class="empty-gameObject-item2">
    <div class="item2">  
    <p style="background: green;"></p>Das Objekt, das du siehst ist es ein Teil von...(w√§hle aus):</p>
    <div class="answers">
      <button class="quiz-button" id="schiff">einem Schiff</button>
      <button class="quiz-button" id="waffe">einer Waffe</button>
      <button class="quiz-button" id="eimer">einem Wassereimer</button>
    </div>
    </div>
  </div>
    
  <div class="item3">3
    <div class="icon-column">
      <img src="/webXR_academy/staticfiles/images/feuerstahlbeschlag_duisburg_einzeln.svg" alt="Feuerstahlbeschlag" width="10"/>
      <img src="/webXR_academy/staticfiles/images/logo_schrift.svg" alt="logoSchrift" width="20"/>
    </div>
  </div>  

  <div class="item4">
  	<div id="textBox"></div>
      <!-- üìå Buttons im HTML -->
      <button id="toggle-nietplatte">Nietplatte an/aus</button>
      <button id="toggle-schiff">Schiff an/aus</button>
    </div>
    
  <div class="item5">
   <button id="nextButton" class="button" style="display:none;">Weiter</button>
  <button id="nextStepButton" class="button" style="display:none;">N√§chster Lernschritt</button>


</div>
  <button id="toggle-panel">Toggle Panel</button></div>

<!-- Script f√ºr Textleiste unten, um Typewriter-Effekt, Pagination und Overflow-Handling des Textes hinzubekommen.-->
<script>
const fullTexts = [
  'Du hast einen Gegenstand gefunden!',
  'Was ist das wohl f√ºr ein Objekt?',
  'Dieses alte Metallst√ºck ist Teil von einem Schiff. Die Erdschicht, in dem es gefunden wurde, ist dem 9. Jahrhundert zuzuordnen. Aus einer schriftlichen √úberlieferung wissen wir, dass es einen √úberfall auf das Handelszentrum von Duisburg gegeben haben soll.', 
  `Dieser √úberfall ist von den Normannen, den Wikingern ausgegangen. Dieser Schiffsniet ist Zeugnis davon, dass die Wikinger tats√§chlich hier gewesen sind. Denn nur an den Schiffen der Wikinger finden sich Schiffsnieten der gleichen Bauart. Schau dir den Schiffsniet genauer an und entdecke neue Informationen.`,
  `Verdichten sich die Informationen √ºber den Aufenthalt der Wikinger, oder ist es doch eher unwahrscheinlich, dass sie Duisburg √ºberfallen haben. Finde es heraus, indem du auch die anderen Gegenst√§nde erkundest!`,
  `Jetzt erf√§hrst du noch mehr √ºber die Wikinger ...`
];


const charsPerPage = 100; // Anzahl Zeichen pro "Seite" (kannst du anpassen)
let currentStep = 0;   // startet bei Lernschritt 0
let currentPage = 0;   // Seite im aktuellen Schritt


const textBox = document.getElementById('textBox');
const nextButton = document.getElementById('nextButton');

function typeWriterEffect(text, callback) {
  let i = 0;
  textBox.textContent = "";
  const interval = setInterval(() => {
    textBox.textContent += text[i];
    i++;
    if (i >= text.length) {
      clearInterval(interval);
      callback();
    }
  }, 30); // Geschwindigkeit (ms pro Buchstabe)
}

function showPage(pageIndex) {
  const fullText = fullTexts[currentStep]; // Text vom aktuellen Lernschritt
  const start = pageIndex * charsPerPage;
  const end = start + charsPerPage;
  let pageText = fullText.slice(start, end);

  if (end < fullText.length) {
    pageText += "...";
  }



  typeWriterEffect(pageText, () => {
    if (end < fullText.length) {
      nextButton.style.display = "block";  // normale Weiter-Page
    } else {      // wir sind am Ende eines Textes
      //Wenn am Ende des ersten Textes, dann...
      if (currentStep === 1) {
        document.querySelector('.item2').style.display = 'block';
      }
      //Wenn am Ende aller weiteren Texte, dann...
      else if (currentStep < fullTexts.length - 1) {
        nextStepButton.style.display = "block"; // neuen Button f√ºr Lernschritt zeigen
      }
    }
  });
}

/*Auswahl der Buttons und definieren, was sie auslesen sollen*/
nextStepButton.addEventListener('click', () => {
  currentStep++;       // n√§chster Lernschritt
  currentPage = 0;     // wieder von Seite 0 starten
  nextStepButton.style.display = "none";
  showPage(currentPage);
});

nextButton.addEventListener('click', () => {
  currentPage++;
  nextButton.style.display = "none";
  showPage(currentPage);
});

document.getElementById('schiff').addEventListener('click', () => {
  currentStep++;
  currentPage = 0;
  document.querySelector('.item2').style.display = 'none';
  showPage(currentPage);
});

// Start bei Seite 0
showPage(0);
</script>


</body>

</html>