<!DOCTYPE html>
<html lang="en">

<head>
	<title>3D Model</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="style.css">
  <script src="https://unpkg.com/three@0.133.0/build/three.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/three@0.133.0/examples/js/loaders/GLTFLoader.js"></script>
<style>

    /* Canvas: immer vorne für Touch-Interaktion */
    .three.js-canvas {
      position: absolute;
      width: 100vw; /* volle Bildschirmbreite */
      height: 100vh; /* volle Bildschirmhöhe */
      z-index: 10; /* Canvas liegt über dem Grid */
    }

    .grid-container {
      position: absolute;
      display: none; /*wird bei sessionstart durch den ARButton in display: grid; verändert*/
      grid-template-columns: 80% 20%;
      grid-template-rows: 1fr 4fr 2fr;
      gap: 0.2em;
      width: 100vw; /* volle Bildschirmbreite */
      height: 100vh; /* volle Bildschirmhöhe */
      background-color: rgba(255, 255, 255, 0.2);
      padding: 1em;
      border-radius: 0.5em;
      box-sizing: border-box;
      overflow: hidden; /* verhindert Scrollen überall */
      z-index: 5;         /* Grid liegt damit unter dem Three.js-canvas */
      pointer-events: none;    /* Hintergrund blockiert keine Touchs */
    }
    /* Buttons im Grid weiterhin interaktiv. (Muss drin stehen, weil das grid im Hintergrund (hinter dem Three.js Canvas) ist und sonst die Buttons nicht anklickbar sind!)) */
    .grid-container button {
      pointer-events: auto;
    }

    .grid-container>div {
      color: #000;
      padding: 0.5em;
	  margin-right: 1em;
      border-radius: 0.5em;
      font-size: 1em;
      text-align: center;
    }

    .item1 {
      grid-column-start: 1;
      grid-column-end: 3;
    }

    .item2 {
      background-color: orange;
      display: none;
    }

    .item3 {
      background-color: orange;
    }

    .item4 {
	background-color: orange;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1em;
    }
    
  #textBox {
    text-align: left;
    word-wrap: break-word;
  }

  .item5 {
    background-color: orange;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .hide {
  display: none !important;
}


	/*Quiz-Buttons innerhalb eines flex-Layouts (siehe .answers)*/
	.quiz-button {
  position: relative; /* wichtig! .quiz-button:after ist ein pseudo-element, das absolut positioniert wird. Deshalb muss der Eltern-Button .quiz-button auf position: relative gesetzt werden, damit sich der Effekt nur innerhalb des Buttons ausbreitet. Ansonsten überlagert der Effekt den ganzen Bildschirm*/
  background-color: #04AA6D;
  border: none;
  border-radius: 0.5em;
  font-size: 1em;
  color: #FFFFFF;
      padding: 1em;
  width: 60%;
  text-align: center;
  transition-duration: 0.4s;
  text-decoration: none;
  overflow: hidden;
  cursor: pointer;
}

.quiz-button:after {
  content: "";
  background: #f1f1f1;
  display: block;
  position: absolute;
  padding-top: 300%;
  padding-left: 350%;
  margin-left: -1em !important;
  margin-top: -120%;
  opacity: 0;
  transition: all 0.8s
}

.quiz-button:active:after {
  padding: 0;
  margin: 0;
  opacity: 1;
  transition: 0s
}

.answers {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    align-items: center;
  }
	/*Quiz-Buttons Ende*/

  /*Hinweis-Icons*/
.icon-column {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    align-items: center;
  }
  /*Hinweis-Icons Ende*/
</style>

</head>

<body>
	<script type="module">
    import { ARButton } from 'https://unpkg.com/three@0.133.0/examples/jsm/webxr/ARButton.js';
    
		let camera, scene, renderer;
		let loader; // we need to create a variable for a gltf model loader
    let model; // das geladene 3D-Model wird hierdrunter gespeichert

		init();
		animate();


		function init() {
			const container = document.createElement('div');
			document.body.appendChild(container);

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.xr.enabled = true; // we have to enable the renderer for webxr
			container.appendChild(renderer.domElement);

      renderer.domElement.classList.add("three.js-canvas"); // Hiermit werden alle Elemente von Three.js (also der Canvas von Three.js) in den Vordergrund gerückt (über CSS-style oben gennent three.js-canvas), sodass das grid nicht die Interaktion mit den Modellen blockiert! 


			var light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
			light.position.set(0.5, 1, 0.25);
			scene.add(light);

      // specify a model URL
      const modelUrl = 'https://raw.githubusercontent.com/sweetsharky/media/refs/heads/main/nietplatte_bearbeitet0.1_gltf/nietplatte_bearbeitet0.1.gltf'; 
      
			// create a GLTF loader object. GLTF is a 3D model format usually called the "JPEG of 3D" because it is
      // fast and efficient to use, which is ideal for the web
			loader = new THREE.GLTFLoader();
      
      // learn about other types of 3D model formats you can use here: 
      // https://threejs.org/docs/#manual/en/introduction/Loading-3D-models
      
      // load the model
      // loader takes in a few arguments loader(model url, onLoad callback, onProgress callback, onError callback)
			loader.load(
				// model URL
				modelUrl,
				// onLoad callback: what get's called once the full model has loaded
				function (gltf) {
          // gltf.scene contains the Three.js object group that represents the 3d object of the model
					model = gltf.scene;
          scene.add(model);
          console.log("Model added to scene");
          

		  // scaling model
		  model.scale.multiplyScalar(0.002);
          // you can optionally change the position of the model
            model.position.z = -0.3; // negative Z moves the model in the opposite direction the camera is facing
           model.position.y = 0; // positive Y moves the model up
            model.position.x = 0; // positive X moves hte model to the right
			},


				// onProgress callback: optional function for showing progress on model load
				//function (xhr) {
		      // console.log((xhr.loaded / xhr.total * 100) + '% loaded' );},
				
			 
			  // onError callback
				function (error) {
					console.error(error);
				}
			);

			document.body.appendChild(ARButton.createButton(renderer, {
				optionalFeatures: ["dom-overlay", "dom-overlay-for-handheld-ar"],
          		domOverlay: { root: document.body}
			}));


      // Wenn eine AR-Session startet → UI einblenden
        renderer.xr.addEventListener('sessionstart', () => {
          document.querySelector('.grid-container').style.display = 'grid';
        });

        // Wenn AR-Session beendet → UI ausblenden
        renderer.xr.addEventListener('sessionend', () => {
          document.querySelector('.grid-container').style.display = 'none';
        });

              //Button, um UI-Panel(grid-Layout) zu sichtbar zu machen/unsichtbar
      document.getElementById('toggle-panel').addEventListener('click', () => {
        document.querySelector('.grid-container').classList.toggle('hide');
      });

            window.addEventListener('resize', onWindowResize, false);



      //ft_model_rot/clickable - Funktion, um Modell mit touch-swipes zu rotieren und anglickbar zu machen
        //modell rotieren       
        let previousTouch = null;
        let rotating = false; // Flag, ob Rotation aktiv ist. Erst sobald raycasting anzeigt, dass auf Model geklickt wurde wird rotating auf true gesetzt. Nur wenn Modell berührt wird, kann Modell also gedreht werden.

        renderer.domElement.addEventListener('touchstart', (event) => {
          if (event.touches.length === 1 && model) {
            const touch = new THREE.Vector2();
            touch.x = (event.touches[0].pageX / window.innerWidth) * 2 - 1;
            touch.y = -(event.touches[0].pageY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(touch, camera);
            const intersects = raycaster.intersectObject(model, true);

            if (intersects.length > 0) {
              rotating = true; // Drehung aktivieren
              previousTouch = { x: event.touches[0].pageX, y: event.touches[0].pageY };
            }
          }
        }, false);

        renderer.domElement.addEventListener('touchmove', (event) => {
          if (event.touches.length === 1 && previousTouch && rotating && model) {
            const deltaX = event.touches[0].pageX - previousTouch.x;
            const deltaY = event.touches[0].pageY - previousTouch.y;

            model.rotation.y += deltaX * 0.01;
            model.rotation.x += deltaY * 0.01;

            previousTouch = { x: event.touches[0].pageX, y: event.touches[0].pageY };
          }
        }, false);

        renderer.domElement.addEventListener('touchend', () => {
          rotating = false;
          previousTouch = null;
        }, false);

          //model anklickbar machen

		}

// Anpassung bei Fenstergröße ändern → Kamera, Renderer und Grid
function onWindowResize() {
    // Three.js anpassen
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);

    
}
/*function init() zuende*/


		function animate() {
			renderer.setAnimationLoop(render);
		}

		function render() {
			renderer.render(scene, camera);
		}

	</script>

<div class="grid-container">
  <div class="item1">Auf den Spuren der Wikinger in Duisburg</div>
  <div class="empty-gameObject-item2">
    <div class="item2">  
    <p style="background: green;"></p>Das Objekt, das du siehst ist es ein Teil von...(wähle aus):</p>
    <div class="answers">
      <button class="quiz-button" id="schiff">einem Schiff</button>
      <button class="quiz-button" id="waffe">einer Waffe</button>
      <button class="quiz-button" id="eimer">einem Wassereimer</button>
    </div>
    </div>
  </div>
    
  <div class="item3">3
    <div class="icon-column">
      <img src="/webXR_academy/staticfiles/images/feuerstahlbeschlag_duisburg_einzeln.svg" alt="Feuerstahlbeschlag" width="10"/>
      <img src="/webXR_academy/staticfiles/images/logo_schrift.svg" alt="logoSchrift" width="20"/>
    </div>
  </div>  

  <div class="item4">
  	<div id="textBox"></div>
    </div>
    
  <div class="item5">
   <button id="nextButton" class="button" style="display:none;">Weiter</button>
  <button id="nextStepButton" class="button" style="display:none;">Nächster Lernschritt</button>


</div>
  <button id="toggle-panel">Toggle Panel</button></div>

<!-- Script für Textleiste unten, um Typewriter-Effekt, Pagination und Overflow-Handling des Textes hinzubekommen.-->
<script>
const fullTexts = [
  'Du hast einen Gegenstand gefunden!',
  'Was ist das wohl für ein Objekt?',
  'Dieses alte Metallstück ist Teil von einem Schiff. Die Erdschicht, in dem es gefunden wurde, ist dem 9. Jahrhundert zuzuordnen. Aus einer schriftlichen Überlieferung wissen wir, dass es einen Überfall auf das Handelszentrum von Duisburg gegeben haben soll.', 
  `Dieser Überfall ist von den Normannen, den Wikingern ausgegangen. Dieser Schiffsniet ist Zeugnis davon, dass die Wikinger tatsächlich hier gewesen sind. Denn nur an den Schiffen der Wikinger finden sich Schiffsnieten der gleichen Bauart. Schau dir den Schiffsniet genauer an und entdecke neue Informationen.`,
  `Verdichten sich die Informationen über den Aufenthalt der Wikinger, oder ist es doch eher unwahrscheinlich, dass sie Duisburg überfallen haben. Finde es heraus, indem du auch die anderen Gegenstände erkundest!`,
  `Jetzt erfährst du noch mehr über die Wikinger ...`
];


const charsPerPage = 100; // Anzahl Zeichen pro "Seite" (kannst du anpassen)
let currentStep = 0;   // startet bei Lernschritt 0
let currentPage = 0;   // Seite im aktuellen Schritt


const textBox = document.getElementById('textBox');
const nextButton = document.getElementById('nextButton');

function typeWriterEffect(text, callback) {
  let i = 0;
  textBox.textContent = "";
  const interval = setInterval(() => {
    textBox.textContent += text[i];
    i++;
    if (i >= text.length) {
      clearInterval(interval);
      callback();
    }
  }, 30); // Geschwindigkeit (ms pro Buchstabe)
}

function showPage(pageIndex) {
  const fullText = fullTexts[currentStep]; // Text vom aktuellen Lernschritt
  const start = pageIndex * charsPerPage;
  const end = start + charsPerPage;
  let pageText = fullText.slice(start, end);

  if (end < fullText.length) {
    pageText += "...";
  }



  typeWriterEffect(pageText, () => {
    if (end < fullText.length) {
      nextButton.style.display = "block";  // normale Weiter-Page
    } else {      // wir sind am Ende eines Textes
      //Wenn am Ende des ersten Textes, dann...
      if (currentStep === 1) {
        document.querySelector('.item2').style.display = 'block';
      }
      //Wenn am Ende aller weiteren Texte, dann...
      else if (currentStep < fullTexts.length - 1) {
        nextStepButton.style.display = "block"; // neuen Button für Lernschritt zeigen
      }
    }
  });
}

/*Auswahl der Buttons und definieren, was sie auslesen sollen*/
nextStepButton.addEventListener('click', () => {
  currentStep++;       // nächster Lernschritt
  currentPage = 0;     // wieder von Seite 0 starten
  nextStepButton.style.display = "none";
  showPage(currentPage);
});

nextButton.addEventListener('click', () => {
  currentPage++;
  nextButton.style.display = "none";
  showPage(currentPage);
});

document.getElementById('schiff').addEventListener('click', () => {
  currentStep++;
  currentPage = 0;
  document.querySelector('.item2').style.display = 'none';
  showPage(currentPage);
});

// Start bei Seite 0
showPage(0);
</script>


</body>

</html>